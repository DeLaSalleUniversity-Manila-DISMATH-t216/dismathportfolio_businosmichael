# dismathportfolio_businosmichael


![alt tag](https://github.com/DeLaSalleUniversity-Manila-DISMATH-t216/dismathportfolio_businosmichael/blob/master/80WslsP_zpsda134d85%5B1%5D.gif)


## Week 1:
**There were confusion in the classroom assignments so the class couldnt meet.**
## Week 2:
**I hope to pass ufufufu.**
- I was reintroduced to Discrete Mathematics and its significance in engineering and the current information society.		
- The Syllabus was explained to us which made it clear what the topics are for this term.		
- Thinking critically and logically is the goal of the course.
- Logical Connectives and their respective truth tables was very similar to general math so it was easy for me to grasp the idea behind it.
- Basic terms like proof, proposition, axioms, etc... was taught to us

| Logical Symbol | Logical Operator |	Shorthand | Logical Expression |
| ------------- |:-------------:| -----:| -----:|
|*¬* | Negation | not |¬p|
|*∧* | Conjunction | and |p ∧ q|
|*∨* | Disjunction  | or |p v q|
|*⊕ * | Exclusive or  | xor |p ⊕ q ≡ (¬p ∧ q) v (p ∧ ¬q)|
|*→* | Conditional  | if, then |p → q ≡ ¬p v q|
|*↔* | Biconditional  | iff |p ↔ q ≡ (p → q) ∧ (q → p)|

- **Propositional Logic**
	- deals with proposition as a whole
  	- Examples of the application of propositional logic was taught to us which made it more interesting to learn.
	- as p → q 
		- Inverse ≡ ¬p → ¬q
		- Converse ≡ q → p
		- Contrapositive ≡ ¬q → ¬p  

- Another Logical tool that can be used to prove propositions are **logical equivalences**.
- I learned to conditional statements and their importance to the course.


## Week 3:
**This topic needs alot of memorizing and im currently confused.**

**Logical Equivalences**	

|Name |	Equivalence|
| -----:| :-----|
|Identity laws |<ul><li> p ∧ T ≡ p	<li> p v F ≡ p</ul>|
|Domination laws |<ul><li> p v T ≡ T <li>p ∧ F ≡ F</ul>|
|Negation laws |<ul><li> p v ¬p ≡ T <li> p ∧ ¬p ≡ F</ul>|
|Double negation law	|<ul><li> ¬(¬p) ≡ p</ul>|
|Idempotent laws	|<ul><li>	p v p ≡ p	<li> p ∧ p ≡ p</ul>|
|Commutative laws |<ul><li>	p v q ≡ q v p <li> p ∧ q ≡ q ∧ p</ul>|
|Associative laws	|<ul><li>	(p v q) v r ≡ p v (q v r)	<li>(p ∧ q) ∧ r ≡ p ∧ (q ∧ r)</ul>|
|Distributive laws	|<ul><li>	p v (q ∧ r) ≡ (p v q) ∧ (p v r)	<li> p ∧(q v r) ≡ (p ∧ q) v (p ∧ r)</ul>|
|De Morgan's laws	|	<ul><li> ¬(p ∧ q) ≡ ¬p v ¬q	<li> ¬(p v q) ≡ ¬p ∧ ¬q</ul>|
|Absorption laws	| <ul><li> p v (p ∧ q) ≡ p	<li> p ∧ (p v q) ≡ p</ul>|

- Important terms such as argument, valid, fallacy, tautology		
	- argument is a sequence of statement that ends with a conclusion.
	- valid means that the conclusion of the argument must follow from the truth of the premises of the argument.
	- fallacy is an invalid argument
	- tautology is a statement that is always true
- Another way of proving propostions are by using the **rules of inference**.

## Week 4:
**With this addition, im more confused but i'll study harder.**

- **Predicate Logic**
	- concern in internal structure in terms of subject and predicate.
- **Quantifiers**
	- Quantifiers has two kinds: Universal and Existensial.
	- Universal (∀x) - "for all" meaing it should be true to all values.
	- Existensial (∃x) - "there exists", meaning it is true to atleast one value. 

## Week 5:
**Now im trying to find a bright future in the midst of these topics.**

**Rules of Inference**	

|Type|	Rule of Inference	|Tautology|
| -----:| -----:|----------:|
|Modus Ponens	|p, p → q ∴ q	|[p ∧ (p → q)] → q|
|Modus Tollens|	¬q, p → q ∴ ¬p|	[¬q ∧ (p → q)] → ¬p|
|Hypothetical Syllogism	|p → q, q → r ∴ p → r	|[(p → q) ∧ (q → r)] → (p → r)|
|Disjunctive Syllogism|	p ∨ q, ¬p ∴ q	|[(p ∨ q) ∧ ¬p] → q|
|Addition	|p ∴ p ∨ q|	p → p ∨ q|
|Simplification|	p ∧ q ∴ p	|(p ∧ q) → p|
|Conjunction|	p, q ∴ p ∧ q|	[(p) ∧ (q)] → (p ∧ q)|
|Resolution|	p ∨ q, ¬p ∨ r ∴ q ∨ r	|[(p ∨ q) ∧ (¬p ∨ r)] → q ∨ r|


**Introduction to Proofs**	

|Method of Proof|Steps|
|:-----|:-------|
|Direct Proof (p → q)|<ol type="1"><li> Assume p is true. <li> Show that q is true (based on 1).	</ol>	|
|Proof by Contraposition (¬q → ¬p)|<ol type="1"><li> Assume ¬q is true. <li> Show that ¬p is true(based on 1).</ol>|		
|Proof by Contradiction|<ol type="1"><li>	Assume ¬p is true. <li> Show that 1. ends up in a contradiction.</ol>	|
|Vacuous Proof (¬p → (p → q))| 1. Show that p is false, because (p → q) must be true when p is false.|
|Trivial Proof (q → (p → q))|	1. how that q is true, it follows that (p → q) must also be true.		|

**Quiz1**

	Before: I feel that i am ready to ace it 
	After: I think i will pass.  
![alt tag](https://github.com/DeLaSalleUniversity-Manila-DISMATH-t216/dismathportfolio_businosmichael/blob/master/tumblr_nylspoavCJ1qjluivo1_540%5B1%5D.gif)
	***tearingupinside***
	
## Week 6
**This monday was sad. I saw my score in the quiz and it let me down. I wasnt expecting it. Atleast Sir gave seatwork that gave plus points.**

![alt tag](https://github.com/DeLaSalleUniversity-Manila-DISMATH-t216/dismathportfolio_businosmichael/blob/master/200_s%5B1%5D.gif)


The main topic was - **Functions**
- **Types of Functions**
    - One-to-one Function (Injection) - functions that never assign the same value to two different domain elements.
    - Onto Function (Surjective) - functions have equal range & co-domain.
    - One-to-one Correspondence (Bijection) - function is both one-to-one and onto.
    
**Algorithms** 
   - Sir said that the main focus of the quiz number 2 would be Algorithms.
   - Algorithm is a finite set of instructions for performming a computations.
   - An algorithm has some qualifications/ properties.
     - Properties of Algorithms
      - INPUT
      - OUTPUT
      - DEFINITENESS
      - CORRECTNESS
      - FINITENESS 
      - EFFECTIVENESS 
      - GENERALITY
	  
**Pseudocode** - is a high-level desciption of an algorithm that uses the structural conventions of programming knowledge.
  - One of the algorithms that i learned is that of Searching algorithms e.g.(linear search)  
   - procedure linear search(x: integer, a1, a2, . . . , an: distinct integers)
    - i := 1
    - while (i ≤ n and x = ai )
    - i := i + 1
    - if i ≤ n then location := i
    - else location := 0
    - return location{location is the subscript of the term that equals x, or is 0 if x is not found}
   	
## Week 7
**If quiz1 taught me anything, it would be that enough is never enough.**

  - Beginning the class with a new searching algorithm 
  - Binary Search
- **Sorting Algorithms**
  - Bubble Sort 
      - procedure bubblesort(a1, . . . , an : real numbers with n ≥ 2)
      - for i := 1 to n − 1
      - for j := 1 to n − i
      - if aj > aj+1 then interchange aj and aj+1
      - {a1, . . . , an is in increasing order}
  - Insertion Sort 
  - Greedy Algorithm 

## Week 8
**Even though i studied over the weekend i still wasnt very confident so ill study more the a few days before quiz**
**Growth of Functions**
  * Using Big-O, Big-Ω,and Big-ϴ
    - Big-O, upper bound
    - Big-Ω, lower bound
    - Big-ϴ, both upper and lower bound 

**Quiz2**


## Week 9
**Thankfully this time when the quiz was returned i passed so i was quite happy.**
**Graph Theory**
- Introduction to Graph Theory
- G=(V,E)It is a structure that consists of Vertices or nodes and Edges or connections.
- Definitions
	- Degree of a node is the number of edges incident with it but loops are counted twice.
	- Subgraph - A graph whose vertices and edges are subsets of another graph.
	- Path is created when walking from node to node along the edges.
	- Pendant is a node with only one degree.
	- Isolated a node with no connections
- Handshaking Theorem: 2e = Sum[deg(v)] where e is the total number of edges in the graph.
- Euler's Circuit and Path
	- Euler's Circuit is a (closed) walk wherein it covers all edges exactly once and goes back to the vertex where it started.
	- exists whenever every vertex in the graph has even degree.
	- while Euler Path is a (open) walk where all edges are covered once. 
	- exists whenever there are exactly two vertices with odd degree.
- Hamilton Circuit and Path
- Hamilton Circuit a (closed) walk where all nodes are covered once and returns to the origin node.
- Hamilton path an open walk where all nodes are covered and does not return to the origin node.
 whenever one appears a graph, a circuit will never be formed; whenever three appears, there can neither be a path nor a circuit.
Adjacency Matrix - to put a graph into a matrix by identifying presence of an edge between vertices (denotation: 1 / 0)
Incidence Matrix - matrix between edges and vertices

**Quiz3**

## Week 10
**When the quiz was returned i was hopeful. But my hopes were quickly shattered. Looking at the bright side 4/7 aint that bad.**
- **Isomorphic Graph** - Graphs that have equal vertices/nodes, and have the same connection.
- **Planar Graph**
  - No edges cross in a graph.
  - Euler's formula for counting the *regions*: r = e - v +2
  - Euler's characteristic: ℵ = r - |e| + |v| = 2
- **Homeomorphic Graphs**
    - Can be obtained from the same graph by a sequence of elementary subdivisions.
    - *Elementary Subdivision* - Everything is planar graph
    - *Kuratowski's Theorem* - Nonplanar if and only if it contains a subgraph homeophobic to K<sub>3,3</sub> and K<sub>5</sub>.
    
    
# Self study on trees
## Notes:
- **Trees** - a connected undirected graph with no simple circuits
	- A **rooted tree** is a tree in which one vertex has been designated as the root and every edge is directed away from the root.
		- **ancestors** - nodes on top
		- **descendants** - children/grandchildren
		- **leaves** - nodes that do not have children
	- **M-ary tree**: A rooted tree is called an m-ary tree if every internal vertex has no more than m children.
	- **Properties of Trees**
		- A tree with n vertices has n − 1 edges.
		- A full m-ary tree with i internal vertices contains n = mi + 1 vertices.
		- A full m-ary tree with
			- n vertices has i = (n − 1)/m internal vertices and l = [(m − 1)n + 1]/m leaves
			- i internal vertices has n = mi + 1 vertices and l = (m − 1)i + 1 leaves
			- l leaves has n = (ml − 1)/(m − 1) vertices and i = (l − 1)/(m − 1) internal vertices.
		
# Final Exam 
on December 12, 2016; A709; 4:30-7:30
